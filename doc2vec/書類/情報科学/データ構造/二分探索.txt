
二分探索
探索 > 二分探索
二分探索（にぶんたんさく、英: binary search、BS）や二分検索やバイナリサーチとは、ソート済み配列に対する探索アルゴリズムの一つ。
目次  [非表示] 
1	概要
2	例
2.1	データが見つかる例
2.2	データが見つからない例(1)
2.3	データが見つからない例(2)
3	コード例
3.1	C言語
3.2	F#
4	実装上の間違い
5	関連項目
6	参照
概要[編集]
ソート済みのリストや配列に入ったデータ（同一の値はないものとする）に対する検索を行うにあたって、 中央の値を見て、検索したい値との大小関係を用いて、検索したい値が中央の値の右にあるか、左にあるかを判断して、片側には存在しないことを確かめながら検索していく。
大小関係を用いるため、未ソートのリストや大小関係の定義されない要素を含むリストには二分探索を用いることはできない。
n個のデータがある場合、時間計算量は {\displaystyle O(\log _{2}n)} O(\log _{2}n)である（O記法）。
n個のデータの中央の値を見ることで、1回の操作でn/2個程度（奇数の場合は(n-1)/2個、偶数の場合はn/2個または(n/2)-1個）の要素を無視することができる。
例[編集]
具体例を示す。
データが見つかる例[編集]
下記のような配列から25を探しだすことを考える。なお、同一のデータは無いものとする。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果欄を設け、目的のデータがあるか否か不明な部分を「?」、データを調べた上で目的のデータが無いとわかった部分を「×」、データを調べるまでもなく目的のデータが無い部分を「×」、目的のデータがあった部分を「○」にすることにする。検索前は、以下のようになる。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	 ?	 ?	 ?	 ?	 ?	 ?	 ?	 ?	 ?	 ?
まず、配列の中央の位置を求めると、(1+10)/2=5　
（端数は切捨、切上のどちらでもいいが、ここは切捨とする。以下同じ）
位置5のデータは12なので「×」、位置1～4まではデータを調べなくても「×」とわかる。目的のデータは位置6～10にあるかもしれない。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	×	×	×	×	×	 ?	 ?	 ?	 ?	 ?
位置6～10の中央の位置は、(6+10)/2=8
位置8のデータは22なので「×」、位置6～7までは「×」とわかる。目的のデータは位置9～10にあるかもしれない。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	×	×	×	×	×	×	×	×	 ?	 ?
位置9～10の中央の位置は、(9+10)/2=9
位置9のデータは25なので目的のデータが見つかったことになる。位置10は調べていないが、同一のデータは存在しないという想定なので「×」としてよい。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	×	×	×	×	×	×	×	×	○	×
データが見つからない例(1)[編集]
下記のような配列から4を探しだすことを考える。なお、同一のデータは無いものとする。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
まず、配列の中央の位置を求めると、(1+10)/2=5　
（端数は切捨、切上のどちらでもいいが、ここは切捨とする。以下同じ）
位置5のデータは12なので「×」、位置6～10まではデータを調べなくても「×」とわかる。目的のデータは位置1～4にあるかも知れない。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	 ?	 ?	 ?	 ?	×	×	×	×	×	×
位置1～4の中央の位置は、(1+4)/2=2
位置2のデータは3なので「×」、位置1も「×」とわかる。目的のデータは位置3～4にあるかも知れない。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	×	×	 ?	 ?	×	×	×	×	×	×
位置3～4の中央の位置は、(3+4)/2=3
位置3のデータは5なので「×」。もし、データ4が存在するならば、位置3のデータ5より小さいので左になるはずである。しかし、すでにそこには存在しないことがわかっている。また、位置3より右である位置4は、データを調べていないが、位置3より大きなデータのはずなので「×」。以上でデータが見つからないという結果になる。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
結果	×	×	×	×	×	×	×	×	×	×
データが見つからない例(2)[編集]
下記のような配列から29を探しだすことを考える。なお、同一のデータは無いものとする。
位置	1	2	3	4	5	6	7	8	9	10
データ	1	3	5	11	12	13	17	22	25	28
データの全体の一番右側が29より小さいので、データが見つからないという結果になる。
コード例[編集]
C言語[編集]
int binary_search(int ary[], int key, int imin, int imax) {
    if (imax < imin) {
        return KEY_NOT_FOUND;
    } else {
        int imid = imin + (imax - imin) / 2;
        if (ary[imid] > key) {
            return binary_search(ary, key, imin, imid - 1);
        } else if (ary[imid] < key) {
            return binary_search(ary, key, imid + 1, imax);
        } else {
            return imid;
        }
    }
}
F#[編集]
let find value (xa: 'T[]) =
  let rec ifind min max =
    if max < min then None
    else
      let c = min + (max - min) / 2
      if xa.[c] > value then ifind min (c - 1)
      else if xa.[c] < value then ifind (c + 1) max
      else Some c
  ifind 0 (xa.Length - 1)

find 8 [|1; 2; 4; 5; 6; 8; 11; 13|]
実装上の間違い[編集]
ドナルド・クヌースは "Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky…" と述べており[1]、二分探索が正確に実装されていないことは多い。Richard E. Pattis の1988年の調査では、書籍20冊のうち15冊が誤っていた[2]。
良くある間違いの一つは、imin + (imax - imin) / 2 を (imax + imin) / 2 としてしまう事である。これでは、imax + imin が int の限界を超えてオーバーフローしてしまう可能性がある。Java の標準ライブラリの Arrays.binarySearch() では JDK 1.2 (1998年) から間違えており、Java 6 (2006年) で修正された[3]。
関連項目[編集]
二分探索木
二分法 - 二分探索のようなアイデアで方程式の近似解を求める方法
参照[編集]
^ Knuth, Donald (1997). “Section 6.2.1: Searching an Ordered Table”. Sorting and Searching. The Art of Computer Programming. 3 (3rd ed.). Addison-Wesley. pp. 409–426. ISBN 0-201-89685-0.
^ Pattis, Richard E. (1988). “Textbook errors in binary searching”. SIGCSE Bulletin 20: 190–194. doi:10.1145/52965.53012. cited at Kruse, Robert (1998). Data Structures and Program Design in C++. Prentice Hall. p. 280. ISBN 0-13-768995-0.
^ Bug ID: JDK-5045582 (coll) binarySearch() fails for size larger than 1<<30
[隠す]
表 話 編 歴
アルゴリズム
ソート	
比較ソート	
バブルソート 選択ソート 挿入ソート シェルソート クイックソート マージソート ヒープソート シェーカーソート コムソート ノームソート 図書館ソート イントロソート 奇偶転置ソート
線形時間ソート	
鳩の巣ソート 基数ソート バケットソート
並行ソート	
ソーティングネットワーク バッチャー奇偶マージソート シェアソート
非効率的	
ボゴソート ストゥージソート
グラフ	
トポロジカルソート
探索	
リスト	
線型探索 二分探索
木・グラフ	
幅優先探索 最良優先探索 均一コスト探索 A* 深さ優先探索 反復深化深さ優先探索 深さ制限探索  双方向探索 分枝限定法
文字列	
クヌース–モリス–プラット法 ボイヤー-ムーア法 エイホ–コラシック法 ラビン-カープ法 Bitap法
最短経路問題	
ダイクストラ法 ベルマン–フォード法 ワーシャル–フロイド法
最小全域木	
プリム法 クラスカル法
最大フロー問題
最小カット問題	
フォード・ファルカーソン法 エドモンズ・カープ法
線型計画問題	
シンプレックス法 カーマーカー法
順序統計量	
選択アルゴリズム 中央値の中央値
種類	
近似アルゴリズム 乱択アルゴリズム
その他	
分割統治法 動的計画法 貪欲法
カテゴリ
カテゴリ: 検索アルゴリズム
案内メニュー
ログインしていませんトーク投稿記録アカウント作成ログインページノート閲覧編集履歴表示検索

Wikipedia内を検索
表示
メインページ
コミュニティ・ポータル
最近の出来事
新しいページ
最近の更新
おまかせ表示
練習用ページ
アップロード (ウィキメディア・コモンズ)
ヘルプ
ヘルプ
井戸端
お知らせ
バグの報告
寄付
ウィキペディアに関するお問い合わせ
印刷/書き出し
ブックの新規作成
PDF 形式でダウンロード
印刷用バージョン
他のプロジェクト
コモンズ
ツール
リンク元
関連ページの更新状況
ファイルをアップロード
特別ページ
この版への固定リンク
ページ情報
ウィキデータ項目
このページを引用
他言語版
العربية
English
Español
हिन्दी
Bahasa Indonesia
한국어
Português
Русский
中文
他 24
リンクを編集
最終更新 2017年7月9日 (日) 06:58 （日時は個人設定で未設定ならばUTC）。
テキストはクリエイティブ・コモンズ 表示-継承ライセンスの下で利用可能です。追加の条件が適用される場合があります。詳細は利用規約を参照してください。
プライバシー・ポリシーウィキペディアについて免責事項開発者Cookieに関する声明モバイルビューWikimedia Foundation Powered by MediaWiki
