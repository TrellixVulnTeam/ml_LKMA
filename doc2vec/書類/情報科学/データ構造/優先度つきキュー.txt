
優先度つきキュー
優先度つきキュー（ゆうせんどつき -、英: priority queue）は、以下の4つの操作をサポートする抽象データ型である。
キューに対して要素を優先度つきで追加する。
最も高い優先度を持つ要素をキューから取り除き、それを返す。
(オプション) 最も高い優先度を持つ要素を取り除くことなく参照する。
(オプション) 指定した要素を取り除くことなく優先度を変更する
目次  [非表示] 
1	実装
1.1	C++
1.2	Java
2	応用例
3	ソートとの関係
4	関連項目
5	参照
実装[編集]
優先度つきキューを実装する最も簡単な方法は、連想配列を用いて、それぞれの優先度に要素のリストを繋げることである。連想リストやハッシュテーブルを連想配列の実装に用いた場合は、要素の追加はO(1)であるが、要素の削除や先頭の参照にはすべてのキーを探索しなければならないのでO(n)かかる。もし、平衡2分探索木を使用した場合は、上記の3つの操作をO(log n)で行うことができる。平衡木は用意されているが、それ以上のものは用意されていない場合は、これが一般的な方法である。 Van Emde Boas treeは連想配列の一種で、上記の3つの操作をO(log log n)で行うことができるが、キューの空間コストがO(2m/2)かかる。ここで、mは優先度を表現するために必要なビット数である。
上記のアプローチよりも性能がよかったり、より多くの操作を提供するヒープデータ構造は多い。
二分ヒープは要素の挿入・削除をO(log n)で、先頭の参照はO(1)で行うことができる。
二項ヒープはいくつかの操作を追加するが、先頭の参照にO(log n)かかる。
フィボナッチヒープは要素の挿入、先頭の参照、プライオリティを下げる操作にO(1)の償却実行時間 (amortized time) で、要素の削除はO(log n)。
C++[編集]
STLにおいては、コンテナアダプタの1つとして、"priority_queue"と呼ばれている。STLの本当のコンテナとは違い、イテレータによる要素へのアクセスを認めていない(ADTの定義に厳密に忠実である)。GCC (libstdc++) の実装では、アルゴリズムを色々と選べるようになっているが、デフォルトはペアリングヒープである[1]。
Java[編集]
java.util.PriorityQueue が標準クラスライブラリにあり、二分ヒープで実装されている。
Java 8 現在、計算量は以下の通り[2]。優先度の変更は API が無いので 先頭以外の削除 → 追加 で実装できるが、先頭以外の削除が一般的な二分ヒープよりも計算量が多いことに注意。ダイクストラ法などで使う場合は違う実装を使った方が良い。
計算量
操作	メソッド名	最悪計算量	平均計算量
先頭の参照	peek	O(1)	O(1)
要素数の取得	size	O(1)	O(1)
追加	add	O(log n)	O(1)
先頭の削除	poll	O(log n)	O(log n)
先頭以外の削除	remove(Object)	O(n)	O(n)
優先度の変更	存在せず	O(n)	O(n)
応用例[編集]
グラフのアルゴリズム - ダイクストラ法, プリム法
バンド幅の管理
オペレーティングシステム - プロセス処理、割り込み処理、ロードバランシング
データ圧縮 - ハフマン符号
離散イベントのシミュレーション。離散イベントのシミュレーションにおいてイベントを管理することである。イベントはシミュレーションの時間を優先度としてキューに追加される。シミュレーションの実行は、繰り返しキューの先頭にある要素を取り出し、イベントを実行することで進む。
ソートとの関係[編集]
優先度つきキューからはソートを思い浮かべることができる。つまり、ソートしたい要素をすべて優先度つきキューに入れて順番に取り出せばそれはソートされている。優先度つきキューによる抽象化を取り除くと、これは実際にいくつかのソートアルゴリズムで用いられている手続きである。このソート法は以下のソートアルゴリズムと等しくなる。
ヒープソートに等しい場合は、優先度つきキューがヒープによって実装されている場合である。
選択ソートに等しい場合は、優先度つきキューが整列されていない配列で実装されている場合である。
挿入ソートに等しい場合は、優先度つきキューが整列された配列で実装されている場合である。
関連項目[編集]
アルゴリズム
データ構造
参照[編集]
^ Priority-Queues
^ PriorityQueue (Java Platform SE 8)
[隠す]
表 話 編 歴
データ構造
データ型	
コレクション（英語版） コンテナ タプル
リスト	
配列 連結リスト キュー 両端キュー 優先度つきキュー  スタック スパゲッティスタック  リングバッファ スキップリスト
連想配列	
ハッシュテーブル ハッシュ関数 コンシステントハッシュ法 分散ハッシュテーブル  マルチマップ（英語版）
セット	
マルチセット 素集合データ構造
木	
二分木	
二分探索木 二重連鎖木
平衡木（英語版）	
2-3木 2-3 フィンガーツリー 2-3-4木
B木	
B+木 B*木
平衡二分探索木	
AA木 AVL木 赤黒木 スプレー木 Treap 木の回転
ヒープ	
二分ヒープ 二項ヒープ フィボナッチヒープ
トライ木	
一般	
基数木 接尾辞木 接尾辞配列 接尾辞オートマトン  三分探索木
整数	
二分トライ木 x-高速トライ木 y-高速トライ木
BSP木	
四分木 八分木 kd木
計算幾何学	
区間木 R木
グラフ	
有向グラフ 有向非巡回グラフ 二分決定グラフ ハイパーグラフ
カテゴリ
カテゴリ: データ構造データ型
案内メニュー
ログインしていませんトーク投稿記録アカウント作成ログインページノート閲覧編集履歴表示検索

Wikipedia内を検索
表示
メインページ
コミュニティ・ポータル
最近の出来事
新しいページ
最近の更新
おまかせ表示
練習用ページ
アップロード (ウィキメディア・コモンズ)
ヘルプ
ヘルプ
井戸端
お知らせ
バグの報告
寄付
ウィキペディアに関するお問い合わせ
印刷/書き出し
ブックの新規作成
PDF 形式でダウンロード
印刷用バージョン
ツール
リンク元
関連ページの更新状況
ファイルをアップロード
特別ページ
この版への固定リンク
ページ情報
ウィキデータ項目
このページを引用
他言語版
Deutsch
English
Español
فارسی
Français
Italiano
한국어
Русский
中文
他 13
リンクを編集
最終更新 2015年11月8日 (日) 17:10 （日時は個人設定で未設定ならばUTC）。
テキストはクリエイティブ・コモンズ 表示-継承ライセンスの下で利用可能です。追加の条件が適用される場合があります。詳細は利用規約を参照してください。
プライバシー・ポリシーウィキペディアについて免責事項開発者Cookieに関する声明モバイルビューWikimedia Foundation Powered by MediaWiki
